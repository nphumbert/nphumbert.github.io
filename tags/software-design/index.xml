<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Design on Nadia Humbert-Labeaumaz</title><link>https://nadiahl.com/tags/software-design/</link><description>Recent content in Software Design on Nadia Humbert-Labeaumaz</description><generator>Hugo</generator><language>en-US</language><copyright>© 2025 Nadia Humbert-Labeaumaz</copyright><lastBuildDate>Sun, 17 Sep 2017 16:09:24 +0200</lastBuildDate><atom:link href="https://nadiahl.com/tags/software-design/index.xml" rel="self" type="application/rss+xml"/><item><title>Testing Java Spring Boot Microservices</title><link>https://nadiahl.com/blog/2017/09/17/testing-java-spring-cloud-microservices/</link><pubDate>Sun, 17 Sep 2017 16:09:24 +0200</pubDate><guid>https://nadiahl.com/blog/2017/09/17/testing-java-spring-cloud-microservices/</guid><description>&lt;p>Tests are an essential part of any codebase.
At a minimum, they help prevent regressions as the code evolves. But not all tests are created equal: unit, integration, component, contract, and end-to-end tests each serve a distinct purpose.&lt;/p>
&lt;p>This article outlines a practical testing strategy for Java Spring Boot microservices, covering the role, scope, and tooling for each test type to help you get the most value from your test suite.&lt;/p></description></item><item><title>How to Write Robust Component Tests</title><link>https://nadiahl.com/blog/2017/09/16/how-to-write-robust-component-tests/</link><pubDate>Sat, 16 Sep 2017 13:37:12 +0200</pubDate><guid>https://nadiahl.com/blog/2017/09/16/how-to-write-robust-component-tests/</guid><description>&lt;p>Component tests check full use cases from start to finish. They’re essential for verifying and documenting how an application or service behaves overall. But they can be expensive, especially in terms of setup and execution time, which is why it’s important to define their scope carefully.&lt;/p>
&lt;p>That said, I’ve often found them cost-effective in distributed architectures. They’re usually simple to set up, since you can reuse the service’s external API without needing extras like fake servers. And since each microservice tends to have a narrow focus, you can test its behavior thoroughly in isolation.&lt;/p>
&lt;p>This article explores how to make component tests more robust, with one key idea: keep them independent of implementation details.&lt;/p></description></item><item><title>Setup a Circuit Breaker with Hystrix, Feign Client and Spring Boot</title><link>https://nadiahl.com/blog/2017/07/23/setup-a-circuit-breaker-with-hystrix/</link><pubDate>Sun, 23 Jul 2017 13:33:38 +0200</pubDate><guid>https://nadiahl.com/blog/2017/07/23/setup-a-circuit-breaker-with-hystrix/</guid><description>&lt;p>In a microservices architecture, many things can go wrong: middleware can fail, the network may be unstable, or the service you’re calling might be down. In this uncertain environment, anticipating failures is crucial to prevent breaking the entire chain and delivering errors to the end user—when you could instead offer a partially degraded experience.&lt;/p>
&lt;p>This article explains how to implement the circuit breaker pattern using Hystrix, Feign Client, and Spring Boot.&lt;/p></description></item><item><title>Refactoring Conditional Structures with Map</title><link>https://nadiahl.com/blog/2017/07/20/refactoring-conditional-with-map/</link><pubDate>Thu, 20 Jul 2017 15:32:15 +0100</pubDate><guid>https://nadiahl.com/blog/2017/07/20/refactoring-conditional-with-map/</guid><description>&lt;p>I often come across code snippets like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Day&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">start&lt;/span>(Weather weather) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span>(weather) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> RAINY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> takeAnUmbrella();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> SUNNY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> takeAHat();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> STORMY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stayHome();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doNothing();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, a specific action depends on the weather. This kind of code is difficult to test and maintain. This short article shows how to refactor it using a &lt;code>Map&lt;/code>.&lt;/p></description></item><item><title>Gérer les dépendances circulaires</title><link>https://nadiahl.com/blog/2016/12/17/gerer-les-dependances-circulaires/</link><pubDate>Sat, 17 Dec 2016 18:31:18 +0100</pubDate><guid>https://nadiahl.com/blog/2016/12/17/gerer-les-dependances-circulaires/</guid><description>&lt;p>Durant mon travail, j&amp;rsquo;ai rencontré des dépendances circulaires dans une application sur laquelle je suis intervenue. Dans sa plus simple forme, il s&amp;rsquo;agit de deux classes qui dépendent l&amp;rsquo;une de l&amp;rsquo;autre.
Ceci est, selon moi, un problème pour plusieurs raisons. L&amp;rsquo;objectif de cet article est de montrer ce qu&amp;rsquo;est une dépendance circulaire, en quoi cela peut poser problème, et comment les éliminer.&lt;/p></description></item><item><title>Refactoring d'une application N-Tiers en utilisant le CQRS</title><link>https://nadiahl.com/blog/2016/06/26/refactoring-architecture-n-tiers-cqrs/</link><pubDate>Sun, 26 Jun 2016 18:14:40 +0200</pubDate><guid>https://nadiahl.com/blog/2016/06/26/refactoring-architecture-n-tiers-cqrs/</guid><description>&lt;p>CQRS, ou &lt;em>Command Query Responsibility Segregation&lt;/em>, est une architecture où la partie &lt;em>Command&lt;/em> (écriture) et la partie &lt;em>Query&lt;/em> (lecture) du système sont séparées.&lt;/p>
&lt;p>J&amp;rsquo;ai eu la chance d&amp;rsquo;assister récemment à une présentation de &lt;a href="https://twitter.com/tjaskula">Tomasz Jaskula&lt;/a> nommée &lt;a href="https://www.youtube.com/watch?v=5Sx_xO-eCE8">Recettes CQRS, pour bien cuisiner son architecture&lt;/a>. Je l&amp;rsquo;ai beaucoup appréciée, notamment car on voit les différentes étapes pour arriver à une architecture CQRS / Event Sourcing / DDD à partir d&amp;rsquo;une architecture N-Tiers &amp;ldquo;classique&amp;rdquo;.&lt;/p>
&lt;p>L&amp;rsquo;objectif de cet article est de présenter ma compréhension et mon avis sur le CQRS en particulier.&lt;/p></description></item><item><title>Que faire lorsqu'une méthode privée veut être testée ?</title><link>https://nadiahl.com/blog/2016/02/21/que-faire-lorsqu-une-methode-privee-veut-etre-testee/</link><pubDate>Sun, 21 Feb 2016 11:09:38 +0100</pubDate><guid>https://nadiahl.com/blog/2016/02/21/que-faire-lorsqu-une-methode-privee-veut-etre-testee/</guid><description>&lt;p>Les tests automatisés servent à vérifier le bon comportement d&amp;rsquo;un objet (ou d&amp;rsquo;un ensemble d&amp;rsquo;objets), indépendamment de la manière dont ce comportement est implémenté. Le comportement d&amp;rsquo;un objet est décrit par son API publique (constructeurs, constantes et méthodes publiques). Les tests ne devraient donc utiliser que cette API.&lt;/p>
&lt;p>Les méthodes privées (et &lt;em>protected&lt;/em>) ne faisant pas partie de l&amp;rsquo;API publique d&amp;rsquo;un objet, elles ne devraient pas être appelées directement par le code de test.&lt;/p>
&lt;p>Cet article a pour objectif de montrer comment réagir lorsqu&amp;rsquo;il paraît nécessaire de tester une méthode privée.&lt;/p></description></item><item><title>Pourquoi ne pas utiliser l'héritage pour éviter la duplication de code ?</title><link>https://nadiahl.com/blog/2016/01/24/heritage-duplication-code/</link><pubDate>Sun, 24 Jan 2016 11:38:41 +0100</pubDate><guid>https://nadiahl.com/blog/2016/01/24/heritage-duplication-code/</guid><description>&lt;p>L&amp;rsquo;héritage est une composante très importante des langages orientés objet tels que Java. Cependant, il doit être utilisé à bon escient afin de respecter les bonnes pratiques de programmation.&lt;/p>
&lt;p>Il m&amp;rsquo;est arrivé de rencontrer des cas où l&amp;rsquo;héritage était utilisé afin de ne pas dupliquer du code. Le but de cet article est d&amp;rsquo;illustrer une telle utilisation, d&amp;rsquo;analyser ses inconvénients et de montrer une manière possible de la corriger.&lt;/p></description></item></channel></rss>