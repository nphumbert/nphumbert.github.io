<!doctype html><html lang=en-US><head><meta charset=utf-8><title>Refactoring d'une application N-Tiers en utilisant le CQRS</title>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Entrepreneur, consultant, bio-sciences and software engineer."><meta name=author content="Nadia Humbert-Labeaumaz"><meta name=generator content="Hugo 0.131.0"><meta property="og:image" content="https://nphumbert.github.io/images/blog/refactoring-cqrs/header.jpg"><meta property="og:url" content="https://nphumbert.github.io/blog/2016/06/26/refactoring-architecture-n-tiers-cqrs/"><meta property="og:site_name" content="Nadia Humbert-Labeaumaz"><meta property="og:title" content="Refactoring d'une application N-Tiers en utilisant le CQRS"><meta property="og:description" content="CQRS, ou Command Query Responsibility Segregation, est une architecture où la partie Command (écriture) et la partie Query (lecture) du système sont séparées.
J’ai eu la chance d’assister récemment à une présentation de Tomasz Jaskula nommée Recettes CQRS, pour bien cuisiner son architecture. Je l’ai beaucoup appréciée, notamment car on voit les différentes étapes pour arriver à une architecture CQRS / Event Sourcing / DDD à partir d’une architecture N-Tiers “classique”.
L’objectif de cet article est de présenter ma compréhension et mon avis sur le CQRS en particulier."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2016-06-26T18:14:40+02:00"><meta property="article:modified_time" content="2016-06-26T18:14:40+02:00"><meta property="article:tag" content="Refactoring"><meta property="article:tag" content="Software Design"><meta property="og:image" content="https://nphumbert.github.io/images/slider.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://nphumbert.github.io/images/slider.jpg"><meta name=twitter:title content="Refactoring d'une application N-Tiers en utilisant le CQRS"><meta name=twitter:description content="CQRS, ou Command Query Responsibility Segregation, est une architecture où la partie Command (écriture) et la partie Query (lecture) du système sont séparées.
J’ai eu la chance d’assister récemment à une présentation de Tomasz Jaskula nommée Recettes CQRS, pour bien cuisiner son architecture. Je l’ai beaucoup appréciée, notamment car on voit les différentes étapes pour arriver à une architecture CQRS / Event Sourcing / DDD à partir d’une architecture N-Tiers “classique”.
L’objectif de cet article est de présenter ma compréhension et mon avis sur le CQRS en particulier."><script async src="https://www.googletagmanager.com/gtag/js?id=G-FDXGPB3FE3"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FDXGPB3FE3")}</script><link rel=stylesheet href=/plugins/bootstrap/css/bootstrap.min.css media=screen><link rel=stylesheet href=/plugins/ionicons/css/ionicons.min.css><link rel=stylesheet href=/plugins/magnific-popup/magnific-popup.min.css><link rel=stylesheet href=/plugins/slick/slick.css><link rel=stylesheet href=/scss/style.min.css media=screen><link rel="shortcut icon" href=/images/favicon.png type=image/x-icon><link rel=icon href=/images/favicon.png type=image/x-icon><link rel=canonical href=https://nphumbert.github.io/blog/2016/06/26/refactoring-architecture-n-tiers-cqrs/></head><body><div class=preloader></div><header class=navigation><div class=container><div class=row><div class=col-md-12><nav class=navbar><div class=navbar-header><button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=#navigation>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse" id=navigation><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/experience>Experience</a></li><li><a href=/blog>Articles</a></li></ul></div></nav></div></div></div></header><section class="page-title bg-2" style=background-image:url(/images/blog/refactoring-cqrs/header.jpg)><div class=container><div class=row><div class=col-md-12><div class=block><h1>Refactoring d'une application N-Tiers en utilisant le CQRS</h1><p></p></div></div></div></div></section><section class=page-wrapper><div class=container><div class=row><div class=col-md-8><div class="post post-single"><h2 class=post-title>Refactoring d'une application N-Tiers en utilisant le CQRS</h2><div class=post-meta><ul><li><i class=ion-calendar></i> June 26, 2016</li><li><i class=ion-android-people></i>
Posted by
<a class=text-primary href=/author/nadia-humbert-labeaumaz>Nadia Humbert-Labeaumaz</a></li><li><i class=ion-pricetags></i>
<a href=/tags/refactoring>Refactoring</a>, <a href=/tags/software-design>Software Design</a></li></ul></div><div class=post-thumb><img class=img-responsive src=/images/blog/refactoring-cqrs/header.jpg alt="Refactoring d'une application N-Tiers en utilisant le CQRS"></div><div class="post-content post-excerpt"><p>CQRS, ou <em>Command Query Responsibility Segregation</em>, est une architecture où la partie <em>Command</em> (écriture) et la partie <em>Query</em> (lecture) du système sont séparées.</p><p>J&rsquo;ai eu la chance d&rsquo;assister récemment à une présentation de <a href=https://twitter.com/tjaskula>Tomasz Jaskula</a> nommée <a href="https://www.youtube.com/watch?v=5Sx_xO-eCE8">Recettes CQRS, pour bien cuisiner son architecture</a>. Je l&rsquo;ai beaucoup appréciée, notamment car on voit les différentes étapes pour arriver à une architecture CQRS / Event Sourcing / DDD à partir d&rsquo;une architecture N-Tiers &ldquo;classique&rdquo;.</p><p>L&rsquo;objectif de cet article est de présenter ma compréhension et mon avis sur le CQRS en particulier.</p><h2 id=mise-en-place>Mise en place</h2><p>Le passage d&rsquo;une architecture N-Tiers à une architecture CQRS est relativement simple, comme montré ci-dessous.</p><p><div class=text-center><figure><img src=/images/drafties/cqrs.png alt=CQRS><figcaption><h5 class=font-weight-bold></h5></figcaption></figure></div></p><p>Concrètement, je pense que cela consiste tout d&rsquo;abord à identifier les requêtes associées à chacune des vues et à les regrouper dans des classes dédiées. Ces classes formeront la partie lecture de l&rsquo;architecture.<br>Ensuite, les objets retournés par ces requêtes sont remplacés par des DTO qui ne contiennent plus que les informations nécessaires à la construction de la vue associée.<br>Finalement, le modèle d&rsquo;écriture peut être débarrassé de toutes ses méthodes et propriétés transitoires, qui ne servaient seulement qu&rsquo;à de la lecture.</p><p>Cette architecture apporte des avantages en termes de maintenabilité et de performances mais peut encore être améliorée.</p><h2 id=conséquences>Conséquences</h2><h3 id=augmentation-de-la-maintenabilité>Augmentation de la maintenabilité</h3><p>L&rsquo;application du CQRS simplifie grandement le modèle d&rsquo;écriture. En effet, il arrive souvent que des propriétés <em>transient</em> soient calculées uniquement pour de l&rsquo;affichage. Ces propriétés, ainsi que les méthodes associées, alourdissent le modèle et n&rsquo;apportent pas de valeur pour les traitements métiers.</p><p>Les services, parfois très lourds, sont remplacés par des classes spécialisées, concises et cohérentes. Ceci permet donc de mieux respecter le <em>Single Responsibility Principle (SRP)</em> ainsi que l&rsquo;<em>Interface Segregation Principle (ISP)</em>. De plus, il n&rsquo;y aura plus de méthodes &ldquo;passe-plat&rdquo; dans les services car celles-ci seront directement implémentées dans les classes de lecture.</p><p>Finalement, l&rsquo;ajout d&rsquo;une nouvelle vue ne risque pas d&rsquo;engendrer de régression car il s&rsquo;agit simplement d&rsquo;ajouter une nouvelle classe de lecture ainsi que le(s) DTO associé(s), sans modifier le reste.</p><h3 id=amélioration-des-performances>Amélioration des performances</h3><p>La séparation de la lecture et de l&rsquo;écriture permet d&rsquo;améliorer les performances du système. En effet, il est difficile d&rsquo;optimiser à la fois la mise à jour et la lecture dans une base de données. Par exemple, l&rsquo;ajout d&rsquo;un index améliore grandement les performances à la lecture mais affecte sensiblement l&rsquo;écriture.</p><p>Ces deux opérations pouvant être séparées dans deux bases différentes, il devient alors possible d&rsquo;optimiser chacune des bases pour son utilisation particulière. De plus, les données de la base de lecture peuvent être dénormalisées, ce qui simplifie grandement les requêtes effectuées et peut les rendre bien plus efficaces.</p><h3 id=pistes-damélioration>Pistes d&rsquo;amélioration</h3><p>Selon moi, la principale difficulté du CQRS réside dans l&rsquo;alimentation de la base de lecture à partir de la base d&rsquo;écriture. Il est possible de la réaliser à l&rsquo;aide d&rsquo;un <em>batch</em> qui se lancera régulièrement. Cependant, l&rsquo;application ne serait plus en temps réel.<br>Une alternative pourrait alors être d&rsquo;écrire dans la base de lecture en même temps que dans la base d&rsquo;écriture. Cette solution n&rsquo;est pas idéale pour moi car elle ne supprime pas le couplage entre la lecture et l&rsquo;écriture. De plus, si cette solution est implémentée via un mécanisme synchrone, il est impossible de paralléliser les traitements lorsque le système est très chargé, ce qui peut affecter nettement les performances.</p><p>La solution d&rsquo;utiliser des événements asynchrones proposée par Tomasz me semble la plus adaptée pour résoudre ces problèmes. Comme il l&rsquo;a indiqué, il faut néanmoins analyser le besoin et la stratégie d&rsquo;entreprise ainsi que les ressources disponibles avant de se lancer dans la mise en place d&rsquo;une telle architecture.</p><h2 id=conclusion>Conclusion</h2><p>Le CQRS est une architecture simple à comprendre et à mettre en place. Elle permet d&rsquo;augmenter la maintenabilité du code et d&rsquo;améliorer les performances des vues. Je pense qu&rsquo;elle peut être mise en place sur un projet (ou une de ses parties) dès que les vues se multiplient et que les services commencent à grossir.</p></div><div class=post-comments></div></div></div><div class=col-md-4><aside class=sidebar><div class="widget widget-latest-post"><h4 class=widget-title>Latest Posts</h4><div class=media><a class=pull-left href=/blog/2021/04/28/effecting-long-lasting-changes/><img class=media-object src=/images/blog/effecting-long-lasting-changes/header.jpg alt="How to Effect Long-Lasting Organisational Changes"></a><div class=media-body><h4 class=media-heading><a href=/blog/2021/04/28/effecting-long-lasting-changes/>How to Effect Long-Lasting Organisational Changes</a></h4></div></div><div class=media><a class=pull-left href=/blog/2021/01/14/what-is-a-social-entrepreneur/><img class=media-object src=/images/blog/what-is-a-social-entrepreneur/header.jpg alt="What is a Social Entrepreneur?"></a><div class=media-body><h4 class=media-heading><a href=/blog/2021/01/14/what-is-a-social-entrepreneur/>What is a Social Entrepreneur?</a></h4></div></div><div class=media><a class=pull-left href=/blog/2020/07/05/debt-sme-nz/><img class=media-object src=/images/blog/debt-sme-nz/header.jpg alt="Debt and SMEs in New Zealand"></a><div class=media-body><h4 class=media-heading><a href=/blog/2020/07/05/debt-sme-nz/>Debt and SMEs in New Zealand</a></h4></div></div><div class=media><a class=pull-left href=/blog/2019/06/27/cloudy-relationship-france-diesel/><img class=media-object src=/images/blog/diesel/header.jpg alt="The Cloudy Relationship Between France and Diesel"></a><div class=media-body><h4 class=media-heading><a href=/blog/2019/06/27/cloudy-relationship-france-diesel/>The Cloudy Relationship Between France and Diesel</a></h4></div></div></div><div class="widget widget-category"><h4 class=widget-title>Categories</h4><ul class=widget-category-list><li><a href=/categories/business/>Business</a></li><li><a href=/categories/case-studies/>Case Studies</a></li><li><a href=/categories/software/>Software</a></li></ul></div><div class="widget widget-tag"><h4 class=widget-title>Tags</h4><ul class=widget-tag-list><li><a href=/tags/change-management/>Change Management</a></li><li><a href=/tags/economics/>Economics</a></li><li><a href=/tags/finance/>Finance</a></li><li><a href=/tags/java/>Java</a></li><li><a href=/tags/refactoring/>Refactoring</a></li><li><a href=/tags/social-entrepreneurship/>Social Entrepreneurship</a></li><li><a href=/tags/software-design/>Software Design</a></li><li><a href=/tags/software-testing/>Software Testing</a></li></ul></div></aside></div></div></div></section><footer class=footer><div class=container><div class=row><div class=col-md-12><div class=footer-menu><ul><li><a href=/>Home</a></li><li><a href=/experience>Experience</a></li><li><a href=/blog>Articles</a></li></ul></div><div class=footer-menu><ul><li><a href=https://www.linkedin.com/in/nadia-humbert-labeaumaz/ target=_blank><i class=ion-social-linkedin-outline></i></a></li><li><a href=https://github.com/nphumbert target=_blank><i class=ion-social-github-outline></i></a></li><li><a href=https://twitter.com/nphumbert target=_blank><i class=ion-social-twitter-outline></i></a></li></ul></div><p class=copyright></p></div></div></div></footer><script src=/plugins/jquery/jquery.min.js></script><script src=/plugins/bootstrap/js/bootstrap.min.js></script><script src=/plugins/slick/slick.min.js></script><script src=/plugins/magnific-popup/magnific-popup.min.js></script><script src=/plugins/shuffle/shuffle.min.js></script><script src=/plugins/google-map/gmap.js defer></script><script src=/js/script.min.js></script></body></html>